<script src="../tinytest.js"></script>
<script>
    // Prototype implementation:
        // function reduce (array, callback, startingValue) {
        //  var resultSoFar = startingValue;
        //  for (var i = 0;i < array.length; i++) {
        //      resultSoFar = callback(resultSoFar, array[i], i, array);
        //  }
        //  return resultSoFar;
        //}

    // array.reduce(callback[,initialValue])
    // Function signature:
        // reduce(array, callback[,initialValue])

    // Callback parameters:
        // previousValue
        // currentValue
        // currentIndex
        // array

    // Return value:
        // Returns a single value.

    function reduce (array, callback, initialValue) {
        var startingIndex = 0;

        // Detects if no initialValue
        if (arguments.length < 3) {
            startingIndex++;
        }

        for (var i = startingIndex;i < array.length; i++) {
            callback(initialValue, array[i], i);
        }
    }

    tests({
        'If initialValue, callback should run array.length times.' : function () {
            var numberOfTimeCallbackHasRun = 0;
            reduce([1,2],function(){
                numberOfTimeCallbackHasRun++;
            },0);
            eq(numberOfTimeCallbackHasRun,2);
        },
        'If no initialValue, callback should run array.length - 1 times.' : function () {
            var numberOfTimeCallbackHasRun = 0;
            reduce([1,2],function(){
                numberOfTimeCallbackHasRun++;
            });
            eq(numberOfTimeCallbackHasRun,1);
        },
        'If initialValue, previousValue should start with initialValue.' : function () {
            reduce([1],function(previousValue) {
                eq(previousValue,0);
            },0);
        },
        'If initialValue, currentValue should start with array[0].' : function () {
            reduce([1],function(previousValue,currentValue) {
                eq(currentValue,1);
            },0);
        },
        'If initialValue, callback will starts at index 0.' : function () {
            reduce([1],function(previousValue,currentValue, currentIndex) {
                eq(currentIndex,0);
            },0);
        },

        'If no initialValue, previousValue should start with array[0].' : function () {
            fail();
        },
        'If no initialValue, currentValue should start with array[1].' : function () {
            fail();
        },
        'If no initialValue, callback will start at index 1.' : function () {
            fail();
        },

        'If no initialValue, and array has one element, it should return that element without calling callback.' : function () {
            fail();
        },
        'If initialValue, and array is empty, return initialValue withouc calling callback.' : function () {
            fail();
        },

        'It should actually reduce.' : function () {
            fail();
        },
        'It should exclude holes.' : function () {
            fail();
        },
        'If array is empty, and no initialValue, throw TypeError.' : function () {
            fail();
        },
        'It should pass array as fourth argument to callback.' : function () {
            fail();
        },
    });

</script>